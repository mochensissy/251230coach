# 可复用_技术_高精度计时器 (React Hook)

## 需求描述
实现一个用于学习/专注的倒计时器。
*   **不仅是倒计时**：需要记录“实际专注时长”。
*   **防后台暂停**：当浏览器 Tab 切换到后台或手机锁屏时，`setInterval` 会被降频或暂停，导致计时不准。必须解决此问题。

## 核心原理
**不要依赖 `setInterval` 的次数累加，而是依赖 `Date.now()` 的差值。**

`elapsed = 当前时间 - (开始时间戳 + 累计暂停时长)`

## 实现代码 (useTimer Hook)

```typescript
import { useState, useRef, useCallback, useEffect } from 'react';

export function useTimer(targetMinutes = 30) {
    const [status, setStatus] = useState('idle'); // idle, running, paused, completed
    const [elapsedSeconds, setElapsedSeconds] = useState(0);
    
    // 使用 ref 存储时间戳，不触发重渲染
    const startTimeRef = useRef<number | null>(null);
    const pausedSecondsRef = useRef(0); // 记录之前由于暂停积累的时长
    const intervalRef = useRef<number | null>(null);

    const start = useCallback(() => {
        if (status === 'running') return;
        
        // 核心公式：倒推“假想的开始时间”
        // StartTime = Now - (已经过去的时间 * 1000)
        // 这样无论何时计算 Now - StartTime，都能得到正确的总时长
        startTimeRef.current = Date.now() - (elapsedSeconds * 1000);
        
        setStatus('running');

        intervalRef.current = window.setInterval(() => {
            const now = Date.now();
            // 实时计算偏差
            const realElapsed = Math.floor((now - startTimeRef.current!) / 1000);
            
            setElapsedSeconds(realElapsed);

            if (realElapsed >= targetMinutes * 60) {
                complete();
            }
        }, 1000);
    }, [status, elapsedSeconds, targetMinutes]);

    const pause = useCallback(() => {
        if (status !== 'running') return;
        clearInterval(intervalRef.current!);
        setStatus('paused');
        // 不需要额外操作，因为 elapsedSeconds 状态已经保留了当前进度
    }, [status]);

    const complete = useCallback(() => {
        clearInterval(intervalRef.current!);
        setStatus('completed');
    }, []);

    // 清理副作用
    useEffect(() => () => clearInterval(intervalRef.current!), []);

    return { status, elapsedSeconds, start, pause };
}
```

## 关键点解析
1.  **后台保活**：由于我们每次 tick 都是用 `Date.now() - startTime` 计算，即使浏览器在后台暂停了 `setInterval` 5分钟，一旦恢复（甚至不恢复，只要下一次 tick 触发），计算出的 `realElapsed` 会瞬间跳变到正确值（例如直接从 10s 跳到 310s），保证**总时长准确**。
2.  **暂停逻辑**：暂停时，只需要停止 interval。再次开始时，利用当前的 `elapsedSeconds` 反推 `startTime`，就像这个计时器是从过去某个时间点连续运行到现在一样。

## 扩展：页面关闭恢复
如果要支持“刷新页面不丢失进度”，只需将 `startTime` 和 `status` 存入 `localStorage`。初始化时检查 Storage 数据并恢复状态即可。
