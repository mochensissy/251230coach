# 可复用_技术_多端数据同步

## 需求描述
实现本地优先（Local-First）的数据架构，允许用户在离线状态下使用，联网后自动同步多端数据。

## 架构设计：Dirty Record (脏记录) 策略

核心思想：**本地数据库 (IndexedDB) + 变更追踪字段**。

### 1. 数据库表设计
在每个通过 IndexedDB 存储的表中，添加同步专用的元数据字段：

```typescript
interface SyncableRecord {
    id: string;
    // ... 业务字段
    
    createdAt: Date;    // 创建时间
    updatedAt: Date;    // 最后修改时间
    syncedAt?: Date;    // 上次成功同步到服务器的时间
}
```

### 2. 本地变更追踪 (Dirty Check)
判断一条记录是否需要同步（"脏"记录）：
*   **新增记录**：`createdAt` 存在，`syncedAt` 不存在。
*   **修改记录**：`updatedAt` > `syncedAt`。
*   **已同步记录**：`syncedAt` >= `updatedAt`。

```typescript
// useSync.ts
const isDirty = (record) => {
    const lastModified = record.updatedAt || record.createdAt;
    if (!lastModified) return false;
    if (!record.syncedAt) return true; // 从未同步过
    return lastModified > record.syncedAt; // 修改时间晚于同步时间
};
```

### 3. 同步流程 (Sync Protocol)

#### 步骤 A: 推送 (Push)
1.  查询本地所有表，筛选出所有 `isDirty` 为 `true` 的记录。
2.  将这些记录打包（按表分类）发送给后端 `/sync` 接口。
3.  后端接收数据，更新数据库。
    *   **冲突解决策略**：简单的“最后写入优先”（LWW）。后端根据 ID 查找，如果存在则更新，不存在则创建。或者更复杂的：如果后端记录的 `updatedAt` 比上传的更新，则拒绝（需要返回冲突）。*本项目采用简单的覆盖策略。*

#### 步骤 B: 拉取 (Pull)
1.  客户端发送 `lastSyncTime`（上次同步成功的时间戳）给后端。
2.  后端查询所有 `updatedAt > lastSyncTime` 的记录。
3.  后端返回这些增量数据。
4.  客户端接收数据，通过 `db.table.put()` 写入本地 IndexedDB。

#### 步骤 C: 确认 (Ack)
1.  同步成功后，客户端更新所有已上传记录的 `syncedAt` 为当前时间。
2.  客户端更新本地的 `lastSyncTime` 标记。

### 4. 关键代码片段 (Dexie.js)

```typescript
// 同步核心函数
const sync = async () => {
    // 1. 获取本地变更
    const localChanges = {
        studyPlans: await db.studyPlans.filter(isDirty).toArray(),
        checkInRecords: await db.checkInRecords.filter(isDirty).toArray(),
        // ...
    };

    // 2. 发送请求
    const lastSyncTime = localStorage.getItem('lastSyncTime');
    const response = await api.sync(lastSyncTime, localChanges);

    // 3. 应用服务器变更 (Pull)
    await db.transaction('rw', db.studyPlans, async () => {
        for (const plan of response.serverChanges.studyPlans) {
            await db.studyPlans.put(plan);
        }
    });

    // 4. 标记本地记录为已同步 (Ack)
    const now = new Date(response.newSyncTime);
    await markAsSynced(localChanges, now);
    localStorage.setItem('lastSyncTime', now.toISOString());
};
```

## 注意事项
1.  **外键依赖**：同步时要小心外键依赖。例如 `StudyPlan` 依赖 `Subject`。建议同步时先同步基础表（Subject），再同步业务表（Plan），或者全量发送基础表。
2.  **软删除**：不要物理删除数据，使用 `deletedAt` 字段标记删除。同步时也同步这个字段，客户端收到后在本地执行删除或标记为删除。
