# 可复用多端同步系统最佳实践与踩坑指南

本文档总结了在开发“小芽成长”多端同步功能时遇到的核心问题及其解决方案。这些经验可直接复用于其他需要离线优先（Local-First）和多端数据同步的项目。

## 1. 核心架构原则

### 1.1 时间戳权威性 (Server Authoritative Timestamp)
**问题**：依赖客户端时间会导致严重的数据一致性问题。如果客户端 A 的时间比服务器慢（例如慢 5 分钟），它上传的数据 `updatedAt` 会比服务器当前的 `lastSyncTime` 小。当客户端 B 稍后来拉取增量数据时（请求 `updatedAt > lastSyncTime`），服务器会直接漏掉这条“旧”数据。

**解决方案**：
*   **强制覆盖**：服务器在接收数据写入数据库时，**必须**强制将 `updatedAt` 字段覆写为服务器当前的系统时间。
*   **原则**：客户端上传的时间仅供参考（或用于冲突解决），但在同步游标（Cursor）逻辑中，必须完全依赖服务器产生的时间轴。

### 1.2 基础数据一致性 (Seeding Strategy)
**问题**：客户端数据往往依赖于服务器端的基础数据（如系统预设的科目、标签等）。如果服务器重新部署或清空数据库后没有重新初始化这些数据，客户端上传的关联数据（如 referencing `subjectId`）会因外键约束失败（Foreign Key Error）。若此时错误处理不当，会导致客户端误以为同步成功。

**解决方案**：
*   **自动播种 (Auto-Seed)**：在服务器启动流程中（`index.ts`），必须加入自动检查并初始化基础数据的逻辑。确保 `App Start -> Seed -> Listen` 的顺序。
*   **幂等性**：Seed 脚本必须是幂等的（Idempotent），即无论运行多少次，结果都一致（使用 `upsert` 而非 `create`）。

## 2. 常见陷阱与调试经验

### 2.1 “假同步成功” (False Positive Sync)
**现象**：客户端显示“同步成功”，但服务器端根本没有数据。
**原因**：服务器端的 `try-catch` 捕获了写入错误（如 FK Error），但为了不阻塞请求，只记录了日志并返回了 200 OK。客户端收到 200 后，将本地脏数据标记为 `synced`，导致这些数据永远不会被重传。
**教训**：
*   **严格报错**：对于无法恢复的数据错误，服务器应返回 4xx/5xx 错误码，让客户端保留“脏”状态以便重试。
*   **修复手段**：如果发生了这种情况，需要客户端提供“强制全量重新上传”的机制，或者引导用户手动修改数据以触发脏检查。

### 2.2 数据覆盖风险 (Last Write Wins Risk)
**现象**：旧设备同步时覆盖了新设备的数据。
**场景**：为了修复数据缺失，如果盲目开启“强制全量上传”，B 端（持有旧数据）可能会把 A 端刚上传的新数据覆盖掉。
**策略**：
*   **坚持增量**：始终坚持只上传 `isDirty = true` 的数据。
*   **版本控制（进阶）**：在 Phase 2 阶段，引入 `version` (int) 或 USN (Update Sequence Number) 字段。写入时检查 `if (newVersion > currentVersion)`，防止旧覆盖新。

## 3. 用户体验优化 (UX)

### 3.1 自动同步时机
用户不会记得每次都点同步。最佳实践是：
*   **Page Mount**: 页面加载/刷新时自动触发后台同步。
*   **Action Trigger**: 关键操作（如完成打卡、新增计划）后自动触发同步。
*   **Focus**: App 回到前台（`window.onfocus`）时触发同步。

### 3.2 视觉反馈
*   **自动刷新**：同步完成后，若当前页面展示了相关数据，应自动重新拉取（Re-fetch）或直接刷新页面（Reload），确保用户看到的是最新的。
*   **精确时间**：显示“上次同步时间：今天 16:05”，给用户掌控感，便于排查数据是否过时。

## 4. 推荐的数据模型 (Prisma 示例)

```prisma
model UserData {
  id        String   @id @default(cuid())
  // 业务字段...
  
  // 同步关键字段
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt // 注意：同步逻辑中应手动覆盖此字段为 ServeTime
  deletedAt DateTime? // 软删除支持：已删除的数据也需要同步给客户端，由客户端执行删除
  
  version   Int      @default(1) // 乐观锁/冲突解决用
}
```

## 5. 调试 Checklist
当遇到“两端数据不一致”时，按此步骤排查：
1.  **查日志**：服务器是否报错（FK Error）？
2.  **查时间**：对比 A 端上传时间、B 端拉取时间、服务器记录的 `updatedAt`。是否存在时间倒流？
3.  **验脏标**：检查客户端 IndexedDB 中的 `syncedAt`。如果 `syncedAt < updatedAt`，说明数据未同步；如果 `syncedAt > updatedAt` 但服务器没数据，说明是“假同步”。
